# Table
- [CORS](#cors)
- [What is Route?](#what-is-route)
- [2FA](#2fa)
- [JWT](#jwt)
- [Sequelize](#sequelize)
- [package.json](#pakcage-jason)
- [Run containder with Dockfile](#run-containder-with-dockfile)
# CORS
## What is CORS?
CORS (Cross-Origin Resource Sharing) is a security mechanism implemented by web browsers to control how web pages from one origin (domain, protocol, or port) can request resources from a different origin. It relies on HTTP headers to allow or block cross-origin requests.<br>

## Why is CORS Needed?
Browsers enforce the Same-Origin Policy (SOP), which restricts web pages from making requests to a different origin unless explicitly allowed. CORS provides a way for servers to relax this restriction securely. <br>

## Real-World Example
Suppose your frontend is hosted at:
```arduino
https://my-frontend.com
```
And it tries to make a request to:
```arduino
https://api.other-backend.com/data
```
Using JavaScript:
```js
fetch('https://api.other-backend.com/data');
```
The browser sees that the origin is different, so it checks if the server at `api.other-backend.com` allows this request.

If not, the browser blocks the request — this is a CORS error.

## How to fix CORS errors?
The backend must explicitly allow cross-origin requests by including specific headers in the response.<br>
Common example:
```http
Access-Control-Allow-Origin: https://my-frontend.com
```
## Other Important Headers
| Header                             | Purpose                                |
| ---------------------------------- | -------------------------------------- |
| `Access-Control-Allow-Origin`      | Specifies which origin(s) are allowed  |
| `Access-Control-Allow-Methods`     | Allowed HTTP methods (GET, POST, etc.) |
| `Access-Control-Allow-Headers`     | Allowed custom headers in requests     |
| `Access-Control-Allow-Credentials` | Allows cookies/auth to be sent         |

# What is Route?
In the context of a web backend like auth-service in the ft_transcendence project, the word "route" refers to a definition of how the server responds to different HTTP requests (like GET, POST, etc.) on specific URLs. <br>

In backend development (especially with frameworks like Fastify, Express, etc.), a route is:<br>

	A way to map a URL path and an HTTP method (like GET, POST) to a specific function (called a handler) that tells the server what to do when that URL is accessed.

So your `routes/` folder contains different files like:<br>
- `2fa.js`: defines the API endpoints (routes) for two-factor authentication.<br>
- `google-auth.js`: defines routes for Google OAuth login.<br>
- `jwt.js`: defines routes related to JWT-based login/authentication.<br>
Each file registers different endpoints that users or other services can call. For example, `POST /login`, `GET /verify`, etc.<br>

# 2FA

## What is 2FA?
Two-Factor Authentication (2FA) is a security process that requires two different types of verification to prove your identity when logging in to an account.<br>

## How it works?
Instead of just entering a password (which is one factor, something you know), 2FA adds a second factor, such as:<br>
1. Something you have – like a phone app (e.g., Google Authenticator, Authy) that generates a 6-digit code.<br>
2. Something you are – like a fingerprint or face recognition (used in more advanced systems).<br>

So when you log in:<br>
- Step 1: You enter your password.<br>
- Step 2: You're asked to enter a verification code from your app or device.<br>

## Why it’s important:
Even if someone steals your password, they can’t log in unless they also have access to your second factor (like your phone).<br>

# JWT
JWT (JSON Web Token) is an open standard (RFC 7519) for securely transmitting information between two parties as a JSON object. It is commonly used for authentication and authorization in web applications and APIs because it is compact, self-contained, and stateless.<br>

A JWT typically consists of three parts, separated by dots (.):<br>
```css
Header.Payload.Signature
```
- **Header**: Specifies the type of token (JWT) and the signing algorithm (e.g., HS256).<br>
- **Payload**: Contains the claims, i.e., user data or additional information (e.g., user ID, roles).<br>
- **Signature**: Ensures the token has not been altered, generated by signing the header and payload with a secret key.<br>

## Why use JWT?

- No need to store session data on the server (stateless).<br>
- Easy to pass between client and server (as an HTTP header, URL parameter, or cookie).<br>
- Widely supported in different languages.<br>

## Where to encode JWT?
- Backend only<br>
- JWT creation involves using a secret key (or private key in asymmetric algorithms like RS256).<br>
- If you expose the secret in frontend code, anyone can generate fake tokens.<br>
- Example: After a user logs in successfully (e.g., with email/password), the backend:<br>
  - Verifies credentials.<br>
  - Generates JWT using the secret key.<br>
  - Sends it to the client (usually in an HTTP response or as a `Set-Cookie` header).<br>

## Where to decode JWT?
There are two cases:<br>
1. Verification (must be backend)<br>
  - The backend must validate the JWT on every protected request.<br>
  - his requires the secret key, so it cannot happen on the frontend.<br>

2. Reading token data (optional on frontend)<br>
  - The frontend may decode the payload (without verification) just to read user info (e.g., username, roles).<br>
  - This is safe because the payload is not trusted and can be tampered with — never use it for security decisions.<br>

## Best practice workflow
1. Frontend → Backend: Send credentials (login request).<br>
2. Backend: Validate credentials → Encode JWT → Return token.<br>
3. Frontend: Stores token in HTTP-only cookies (recommended for security).<br>
4. Frontend → Backend: Send token with every request (usually in `Authorization: Bearer <token> `header).<br>
5. Backend: Decode + verify JWT → Authorize user → Respond.<br>

## Step-by-Step Flow
1. Frontend needs personal data<br>
Example:
```sql
GET /api/user/profile
```
2. Frontend sends JWT <br>
  - The request includes the token (from `localStorage` or, preferably, an HTTP-only cookie or `Authorization: Bearer <token>` header).<br>
3. Backend verifies JWT (authentication)<br>
  - Checks the signature to make sure the token is valid.<br>
  - Checks if the token is expired.<br>
  - Extracts user ID and roles from the payload.<br>
4. Backend authorizes (if needed)<br>
  - If the endpoint requires special permissions, check user roles in the JWT payload.<br>
5. Backend responds with personal data<br>
  - Example response:<br>
  ```json
  {
  "id": "12345",
  "name": "John Doe",
  "email": "john@example.com"
  }
  ```
**Key Principle:**
  - Every protected resource request → requires authentication first.<br>
  - The JWT is your “proof” of who the user is.<br>




# Sequelize
Sequelize is a Node.js ORM (Object-Relational Mapping) for SQL databases like PostgreSQL, MySQL, MariaDB, SQLite, and MSSQL. It lets you interact with your database using JavaScript instead of writing raw SQL queries.<br>

```js
const { DataTypes } = require('sequelize');
```
is using destructuring assignment to import the DataTypes object from the sequelize library. <br>

## DataTypes
`DataTypes` is an object provided by Sequelize that defines the types of data you can use for your model fields, such as:<br>
- `DataTypes.STRING` – for text<br>
- `DataTypes.INTEGER` – for integers<br>
- `DataTypes.BOOLEAN` – for true/false<br>
- `DataTypes.DATE` – for dates/timestamps<br>
- `DataTypes.FLOAT`, DataTypes.TEXT, etc.<br>

# package.json
`package.json` is the metadata file that lives at the root of a Node.js project. It defines:<br>
- Project name, version, and description<br>
- Your dependencies<br>
- Scripts to build, test, or run your app<br>
- Entry point for the app (`main`)<br>
- Author info, license, and more<br>
It’s essential for npm (Node Package Manager) to install, run, and maintain your project and its dependencies.<br>

Example: <br>
```json
{
  "name": "my-app",
  "version": "1.0.0",
  "description": "My first Node.js app",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"No test specified\" && exit 0"
  },
  "keywords": ["node", "example"],
  "author": "Sherry",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  }
}
```
## Dependencies vs DevDependencies
- dependencies: Needed in production.<br>
- devDependencies: Needed only for development (e.g., linters, test frameworks).<br>
`dependencies` are always installed in development, unless you specifically tell npm to skip them (e.g., `--production`). <br>

##  Versioning (Semantic Versioning)
In dependencies:<br>
- "^1.2.3" = any minor or patch updates (1.x.x)<br>
- "~1.2.3" = only patch updates (1.2.x)<br>
- "1.2.3" = exact version<br>

# Run containder with Dockfile
1. Navigate to the service root folder;<br>
2. Build the image from the Dockerfile:
```bash
docker build -t auth-service .
```
- `-t auth-service` assigns a name to your image.<br>
- `. `uses the current directory (where the Dockerfile is) as the build context.<br>
3. Run the container:
```bash
docker run -d -p 3001:3001 --name auth-service-container auth-service
```
- -d → Detached mode.<br>
- -p 3001:3001 → Maps container’s port 3001 to your host’s port 3001.<br>
- --name auth-service-container → Gives the container a name.<br>
- auth-service → The image you built in step 2.<br>

4. Stop the containder:
```bash
docker stop auth-service-container
docker rm auth-service-container
```

If you need environment variable from `.env` to be loaded when you run this container:
```bash
docker run -d -p 3001:3001 --env-file .env --name auth-service-container auth-service
```

## Run a single test file
1. Build the container image;
2. Run a container interactively for executing the test:
```bash
docker run --rm -it --env-file .env auth-service sh
```
- --rm → Remove the container after it exits.
- -it → Interactive shell.
- --env-file .env → Load environment variables from your .env file.
- auth-service → The image you built.
- sh → Opens a shell inside the container.
3. Inside the container, run:
```bash
npm test -- test/unit/db.test.js
```
or if you used Jtest, you can run the command as:
```bash
npx jest test/unit/db.test.js
```
