# Table
- [CORS](#cors)
- [What is Route?](#what-is-route)
- [2FA](#2fa)
- [JWT](#jwt)
- [Hash a password](#hash-a-password)
- [Sequelize](#sequelize)
- [package.json](#pakcage-jason)
- [Run containder with Dockfile](#run-containder-with-dockfile)
- [Jest](#jest)
# CORS
## What is CORS?
CORS (Cross-Origin Resource Sharing) is a security mechanism implemented by web browsers to control how web pages from one origin (domain, protocol, or port) can request resources from a different origin. It relies on HTTP headers to allow or block cross-origin requests.<br>

## Why is CORS Needed?
Browsers enforce the Same-Origin Policy (SOP), which restricts web pages from making requests to a different origin unless explicitly allowed. CORS provides a way for servers to relax this restriction securely. <br>

## Real-World Example
Suppose your frontend is hosted at:
```arduino
https://my-frontend.com
```
And it tries to make a request to:
```arduino
https://api.other-backend.com/data
```
Using JavaScript:
```js
fetch('https://api.other-backend.com/data');
```
The browser sees that the origin is different, so it checks if the server at `api.other-backend.com` allows this request.

If not, the browser blocks the request — this is a CORS error.

## How to fix CORS errors?
The backend must explicitly allow cross-origin requests by including specific headers in the response.<br>
Common example:
```http
Access-Control-Allow-Origin: https://my-frontend.com
```
## Other Important Headers
| Header                             | Purpose                                |
| ---------------------------------- | -------------------------------------- |
| `Access-Control-Allow-Origin`      | Specifies which origin(s) are allowed  |
| `Access-Control-Allow-Methods`     | Allowed HTTP methods (GET, POST, etc.) |
| `Access-Control-Allow-Headers`     | Allowed custom headers in requests     |
| `Access-Control-Allow-Credentials` | Allows cookies/auth to be sent         |

# What is Route?
In the context of a web backend like auth-service in the ft_transcendence project, the word "route" refers to a definition of how the server responds to different HTTP requests (like GET, POST, etc.) on specific URLs. <br>

In backend development (especially with frameworks like Fastify, Express, etc.), a route is:<br>

	A way to map a URL path and an HTTP method (like GET, POST) to a specific function (called a handler) that tells the server what to do when that URL is accessed.

So your `routes/` folder contains different files like:<br>
- `2fa.js`: defines the API endpoints (routes) for two-factor authentication.<br>
- `google-auth.js`: defines routes for Google OAuth login.<br>
- `jwt.js`: defines routes related to JWT-based login/authentication.<br>
Each file registers different endpoints that users or other services can call. For example, `POST /login`, `GET /verify`, etc.<br>

# 2FA

## What is 2FA?
Two-Factor Authentication (2FA) is a security process that requires two different types of verification to prove your identity when logging in to an account.<br>

## How it works?
Instead of just entering a password (which is one factor, something you know), 2FA adds a second factor, such as:<br>
1. Something you have – like a phone app (e.g., Google Authenticator, Authy) that generates a 6-digit code.<br>
2. Something you are – like a fingerprint or face recognition (used in more advanced systems).<br>

So when you log in:<br>
- Step 1: You enter your password.<br>
- Step 2: You're asked to enter a verification code from your app or device.<br>

## Why it’s important:
Even if someone steals your password, they can’t log in unless they also have access to your second factor (like your phone).<br>

# JWT
JWT (JSON Web Token) is an open standard (RFC 7519) for securely transmitting information between two parties as a JSON object. It is commonly used for authentication and authorization in web applications and APIs because it is compact, self-contained, and stateless.<br>

A JWT typically consists of three parts, separated by dots (.):<br>
```css
Header.Payload.Signature
```
- **Header**: Specifies the type of token (JWT) and the signing algorithm (e.g., HS256).<br>
- **Payload**: Contains the claims, i.e., user data or additional information (e.g., user ID, roles).<br>
- **Signature**: Ensures the token has not been altered, generated by signing the header and payload with a secret key.<br>

## Why use JWT?

- No need to store session data on the server (stateless).<br>
- Easy to pass between client and server (as an HTTP header, URL parameter, or cookie).<br>
- Widely supported in different languages.<br>

## Where to encode JWT?
- Backend only<br>
- JWT creation involves using a secret key (or private key in asymmetric algorithms like RS256).<br>
- If you expose the secret in frontend code, anyone can generate fake tokens.<br>
- Example: After a user logs in successfully (e.g., with email/password), the backend:<br>
  - Verifies credentials.<br>
  - Generates JWT using the secret key.<br>
  - Sends it to the client (usually in an HTTP response or as a `Set-Cookie` header).<br>

## Where to decode JWT?
There are two cases:<br>
1. Verification (must be backend)<br>
  - The backend must validate the JWT on every protected request.<br>
  - his requires the secret key, so it cannot happen on the frontend.<br>

2. Reading token data (optional on frontend)<br>
  - The frontend may decode the payload (without verification) just to read user info (e.g., username, roles).<br>
  - This is safe because the payload is not trusted and can be tampered with — never use it for security decisions.<br>

## Best practice workflow
1. Frontend → Backend: Send credentials (login request).<br>
2. Backend: Validate credentials → Encode JWT → Return token.<br>
3. Frontend: Stores token in HTTP-only cookies (recommended for security).<br>
4. Frontend → Backend: Send token with every request (usually in `Authorization: Bearer <token> `header).<br>
5. Backend: Decode + verify JWT → Authorize user → Respond.<br>

## Step-by-Step Flow
1. Frontend needs personal data<br>
Example:
```sql
GET /api/user/profile
```
2. Frontend sends JWT <br>
  - The request includes the token (from `localStorage` or, preferably, an HTTP-only cookie or `Authorization: Bearer <token>` header).<br>
3. Backend verifies JWT (authentication)<br>
  - Checks the signature to make sure the token is valid.<br>
  - Checks if the token is expired.<br>
  - Extracts user ID and roles from the payload.<br>
4. Backend authorizes (if needed)<br>
  - If the endpoint requires special permissions, check user roles in the JWT payload.<br>
5. Backend responds with personal data<br>
  - Example response:<br>
  ```json
  {
  "id": "12345",
  "name": "John Doe",
  "email": "john@example.com"
  }
  ```
**Key Principle:**
  - Every protected resource request → requires authentication first.<br>
  - The JWT is your “proof” of who the user is.<br>

# Hash a password

## How many ways to hash a password?
There are several cryptographic algorithms and methods for hashing passwords, but the important part is not to use plain hash algorithms like SHA or MD5 alone, because they are fast and vulnerable to brute-force attacks. Instead, password hashing functions are designed to be slow and salted. Commonly used secure password-hashing algorithms include:<br>
**1. bcrypt**
  - Uses the Blowfish cipher internally.<br>
  - Adaptive: you can increase the cost factor as hardware improves.<br>
  - Widely used in web applications.<br>
**2. argon2 (specifically Argon2id)**
  - Winner of the Password Hashing Competition (PHC).<br>
  - Memory-hard (resistant to GPU/ASIC attacks).<br>
  - Newer and considered more secure than bcrypt.<br>
**3. scrypt**
  - Memory-hard algorithm like Argon2.<br>
  - More resistant to large-scale brute-force attacks than bcrypt.<br>
**4. PBKDF2 (Password-Based Key Derivation Function 2)**
  - Uses HMAC (Hash-based Message Authentication Code).<br>
  - Slower than plain SHA but still widely used in legacy systems.<br>
❌ **Not recommended for password hashing alone:**
  - SHA-256, SHA-512, MD5 (too fast, easy to crack).<br>

## Which is most popular in JavaScript?
In JavaScript (Node.js), the most popular password hashing library is:<br>
- `bcrypt` → via the `bcrypt` npm package<br>
  - Mature, easy to use, and widely supported.<br>
  - Good default for most applications.<br>
Example:<br>
```javascript
const bcrypt = require('bcrypt');

const password = 'myPassword123';
const saltRounds = 10;

// Hash password
const hash = await bcrypt.hash(password, saltRounds);

// Verify password
const isMatch = await bcrypt.compare(password, hash);
console.log('Password match:', isMatch);
```
**Alternatives in Node.js:**
- argon2 (via argon2 npm package) → More secure, but slightly less common.<br>
- crypto (built-in module) → Can implement PBKDF2, but requires more setup.<br>

## About saltRounds

### What is saltRounds in bcrypt?
- saltRounds (also called cost factor or work factor) defines how many times the hashing algorithm will be applied internally.<br>
- It controls the computational complexity and time it takes to generate the hash.<br>

### How it works:
- bcrypt automatically generates a **random salt** for each password hash.<br>
- The `saltRounds` parameter determines **how expensive (slow) the hashing process** is by increasing the number of iterations or the complexity of the key setup.<br>
- Higher `saltRounds` means:<br>
  - More CPU time needed to compute the hash (slower).<br>
  - Harder for attackers to brute-force or guess passwords, because each guess requires more work.<br>

### Typical values:
- Common values range from **10 to 12**.<br>
- `saltRounds = 10` means about 2^10 = 1024 rounds internally (rough estimate).<br>
- Increasing the rounds improves security but also slows down login and registration, so you need to balance security and performance.<br>

### Summary:
- `saltRounds` **controls the cost/complexity of the hash function**.<br>
- It **makes the hashing slower**, which **protects against brute-force attacks**.<br>
- Each password gets a **unique random salt automatically** by bcrypt, separate from the rounds.<br>

## Core Functions in bcrypt (Node.js version)
1. `bcrypt.hash(data, saltRounds)`<br>
  - Purpose: Hash a password with a random salt and given cost factor.<br>
  - Parameters:<br>
    - `data`: The plain text password.<br>
    - `saltRounds`: Number of rounds to process (work factor).<br>
  - Returns: A hashed string (including the salt inside).<br>
  - Example:<br>
  ```javascript
  const hash = await bcrypt.hash('myPassword', 10);
  console.log(hash); // $2b$10$...
  ```
2. `bcrypt.compare(data, hash)`<br>
  - Purpose: Verify if a plain text password matches a hashed password.<br>
  - Parameters:<br>
    - data: The plain text password.<br>
    - hash: The hashed password from the database.<br>
  - Returns: `true` or `false`.<br>
  - Example:<br>
  ```javascript
  const isMatch = await bcrypt.compare('myPassword', hash);
  console.log(isMatch); // true or false
  ```
3. `bcrypt.genSalt(saltRounds)`<br>
  - Purpose: Generate a salt manually (bcrypt usually does this internally).<br>
  - Parameters:<br>
    - saltRounds: Number of rounds for complexity.<br>
  - Returns: A salt string.<br>
  - Example:<br>
    ```javascript
  const salt = await bcrypt.genSalt(10);
  console.log(salt);
  ```

# Sequelize
Sequelize is a Node.js ORM (Object-Relational Mapping) for SQL databases like PostgreSQL, MySQL, MariaDB, SQLite, and MSSQL. It lets you interact with your database using JavaScript instead of writing raw SQL queries.<br>

```js
const { DataTypes } = require('sequelize');
```
is using destructuring assignment to import the DataTypes object from the sequelize library. <br>

## DataTypes
`DataTypes` is an object provided by Sequelize that defines the types of data you can use for your model fields, such as:<br>
- `DataTypes.STRING` – for text<br>
- `DataTypes.INTEGER` – for integers<br>
- `DataTypes.BOOLEAN` – for true/false<br>
- `DataTypes.DATE` – for dates/timestamps<br>
- `DataTypes.FLOAT`, DataTypes.TEXT, etc.<br>

# package.json
`package.json` is the metadata file that lives at the root of a Node.js project. It defines:<br>
- Project name, version, and description<br>
- Your dependencies<br>
- Scripts to build, test, or run your app<br>
- Entry point for the app (`main`)<br>
- Author info, license, and more<br>
It’s essential for npm (Node Package Manager) to install, run, and maintain your project and its dependencies.<br>

Example: <br>
```json
{
  "name": "my-app",
  "version": "1.0.0",
  "description": "My first Node.js app",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "test": "echo \"No test specified\" && exit 0"
  },
  "keywords": ["node", "example"],
  "author": "Sherry",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  }
}
```
## Dependencies vs DevDependencies
- dependencies: Needed in production.<br>
- devDependencies: Needed only for development (e.g., linters, test frameworks).<br>
`dependencies` are always installed in development, unless you specifically tell npm to skip them (e.g., `--production`). <br>

##  Versioning (Semantic Versioning)
In dependencies:<br>
- "^1.2.3" = any minor or patch updates (1.x.x)<br>
- "~1.2.3" = only patch updates (1.2.x)<br>
- "1.2.3" = exact version<br>

# Run containder with Dockfile
1. Navigate to the service root folder;<br>
2. Build the image from the Dockerfile:
```bash
docker build -t auth-service .
```
- `-t auth-service` assigns a name to your image.<br>
- `. `uses the current directory (where the Dockerfile is) as the build context.<br>
or
```bash
docker build --target dev -t auth-service-dev .
```
When you have deve and pro two targets in Dockerfile;<br>
3. Run the container:
```bash
docker run -d -p 3001:3001 --name auth-service-container auth-service
```
- -d → Detached mode.<br>
- -p 3001:3001 → Maps container’s port 3001 to your host’s port 3001.<br>
- --name auth-service-container → Gives the container a name.<br>
- auth-service → The image you built in step 2.<br>

4. Stop the containder:
```bash
docker stop auth-service-container
docker rm auth-service-container
```

If you need environment variable from `.env` to be loaded when you run this container:
```bash
docker run -d -p 3001:3001 --env-file .env --name auth-service-container auth-service
```

## Run a single test file
1. Build the container image;
2. Run a container interactively for executing the test:
```bash
docker run --rm -it --env-file .env auth-service sh
```
- --rm → Remove the container after it exits.
- -it → Interactive shell.
- --env-file .env → Load environment variables from your .env file.
- auth-service → The image you built.
- sh → Opens a shell inside the container.
3. Inside the container, run:
```bash
npm test -- test/unit/db.test.js
```
or if you used Jtest, you can run the command as:
```bash
npx jest test/unit/db.test.js
```

# Jest

## execpt()
`expect()` is a global function provided by Jest (a popular JavaScript testing framework). It takes the actual value you want to test and returns an expectation object, which you can then chain with matchers (like `.toBe()`, `.toEqual()`, `.toBeUndefined()`, etc.) to write assertions. <br>
```javascript
expect(2 + 2).toBe(4);
```
- `expect(2 + 2)` → creates an expectation object with the value 4.
- `.toBe(4)` → asserts that the value is strictly equal (===) to 4.

## matchers

**1. `.toBe(value)` -- Strict Equality (===)**
- Best for primitive values (numbers, strings, booleans).
- Fails for objects and arrays because those compare by reference.

```javascript
expect(5).toBe(5);             // ✅ Pass
expect('hello').toBe('hello'); // ✅ Pass
expect({a:1}).toBe({a:1});     // ❌ FAIL (different object references)
```

**2. `.toEuqal(value)` -- Deep Equality**
- Checks structural equality (recursively compares object contents).
- Use this for objects and arrays.
```javascript
expect({a:1}).toEqual({a:1});   // ✅ Pass
expect([1,2,3]).toEqual([1,2,3]); // ✅ Pass
```
Tip: .toEqual() ignores object property order but not value differences.<br>

**3. `.toBeUndefined()`**
- Passes if the received value is exactly undefined.
- Does not pass for null or other falsy values.
```javascript
let x;
expect(x).toBeUndefined();  // ✅ Pass
expect(null).toBeUndefined(); // ❌ FAIL
```
**4. `.toBeNull()`**
- Checks if the value is null.
```javascript
let x;
expect(null).toBeNull(); // ✅ Pass
```
**5. `.toBeDefined()`**
- Opposite of .toBeUndefined().
- Passes for any value except undefined.
```javascript
expect('Hello').toBeDefined(); // ✅ Pass
```
**6. `.toBeTruthy() / .toBeFalsy()`**
- Checks if a value is truthy or falsy in a boolean context.
```javascript
expect(1).toBeTruthy();     // ✅ Pass
expect(0).toBeFalsy();      // ✅ Pass
expect('').toBeFalsy();     // ✅ Pass
```
**7. `.toContain(item)`**
- Works for arrays, strings, and iterables.
- Checks if item exists.
```javascript
expect([1, 2, 3]).toContain(2);
expect('hello world').toContain('world');
```
**8. `.toHaveLength(number)`**
- Checks the .length property of arrays, strings.
```javascript
expect([1, 2, 3]).toHaveLength(3);
expect('hello').toHaveLength(5);
```
**9. `.toHaveProperty(keyPath, value?)`**
- Checks if an object has a property.
- Optionally, verify the value.
```javascript
const user = { name: 'Alice', address: { city: 'Paris' }};
expect(user).toHaveProperty('name');              // ✅
expect(user).toHaveProperty('address.city', 'Paris'); // ✅
```
**10. `.toMatch(regexOrString)`**
- For string matching with regex or substring.
```javascript
expect('hello world').toMatch(/world/);    // ✅ Pass
expect('hello world').toMatch('world');    // ✅ Pass (string also works)
expect('hello world').toMatch(/WORLD/);    // ❌ Fail (regex is case-sensitive by default)
expect('hello world').toMatch(/WORLD/i);   // ✅ Pass (case-insensitive with `i`)
```
**11. `.toThrow(error?)`**
- Checks if a function throws an error.
- Optionally match the error message or type.
```javascript
function bad() { throw new Error('Boom'); }
expect(bad).toThrow('Boom');
```
**12. `.toBeGreaterThan(number)` / `.toBeLessThan(number)`**
- For comparing numbers.
```javascript
expect(10).toBeGreaterThan(5);
expect(3).toBeLessThan(5);
```
