# How to do the protection

## What is SQL injection and XSS attacks

ðŸ‘‰ In short:
SQL Injection = attacking the database.<br>
XSS = attacking the usersâ€™ browsers.<br>

### SQL injection
SQL Injection is a type of attack where an attacker tricks your application into running malicious SQL queries by inserting special input into fields like forms, URLs, or API parameters.<br>

### XSS (Cross-Site Scripting) attacks
XSS is a web security vulnerability where an attacker injects malicious JavaScript into a website, so that it runs in another userâ€™s browser.<br>
This usually happens when user input is shown on a webpage without proper escaping.
For example, if someone types:<br>
```html
<script>alert("Hacked!");</script>
```

## Concrete ways to protect against SQL injection (Node.js / Express / Sequelize / MySQL/Postgres)

### Backend

The backend is where SQL injection really happens, so this is the **most critical layer.**<br>
**a.** Always use parameterized queries / prepared statements (never string-concatenate user input into SQL).<br>
**what we did**
use model methods (User.findOne({ where: { email } })) or parameter binding â€” avoid building SQL strings.<br>
**Safer way to query:**<br>
```js
const inputEmail = foo@example.com' OR '1'='1;
// Using Sequelize model methods
const user = await User.findOne({
  where: { email: inputEmail }
});

// Also safe with raw query binding
const [results] = await sequelize.query(
  'SELECT * FROM users WHERE email = :email',
  {
    replacements: { email: inputEmail },
    type: sequelize.QueryTypes.SELECT
  }
);
```
**Not safe way to query:**<br>
```js
// Dangerous - direct string concatenation
const inputEmail = foo@example.com' OR '1'='1;
const query = `SELECT * FROM users WHERE email = '${inputEmail}'`;

const [results] = await sequelize.query(query);
```
**Why the first way it safer??**<br>
example:
```js
const email = foo@example.com' OR '1'='1;
```
Still with same the input email value, for the safer way it will replace like this:
```js
const user = await User.findOne({
  where: { email: "foo@example.com' OR '1'='1" }
});
```
And the real SQL script is:
```sql
SELECT * FROM users WHERE email = 'foo@example.com'' OR ''1''=''1';
```
the email passes as a whole string.<br>
But if we use the not safe way, the SQL script will be:
```sql
SELECT * FROM users WHERE email = 'foo@example.com' OR '1'='1'
```
The "OR '1'='1'" will be recognaized as a script and executed. Then it will return all users (that is the  classic SQL injection). <br>

**b.** Validate and sanitize inputs
  - Check type, length, format before hitting the database.<br>
  - Example using validator.js:<br>
  ```js
  const validator = require('validator');
  if (!validator.isEmail(req.body.email)) {
    return res.status(400).send('Invalid email');
  }
  ```
  **What we did**
  - Limited each column length in DB level.
  - validate the each data before inserting into DB.

**c** Limit database permissions
Use a DB user with least privilege â€” e.g., no DROP or DELETE if not needed.<br>

### Frontend
Frontend canâ€™t prevent SQL injection directly, because SQL runs on the server. But the frontend can reduce risk and help overall security:<br>
**a.** Input validation before sending
Check email format, string length, allowed characters.
```js
if (!/^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$/.test(email)) {
  alert('Invalid email!');
}
```
**b.** Avoid exposing raw SQL or database errors
- Never return raw DB error messages to users.
- Show generic error messages: "Invalid credentials" instead of "SQL syntax error at line 1".

**c.** Use HTTPS and secure headers
- HTTPS prevents attackers from modifying requests in transit.
- Headers like Content-Security-Policy and X-Content-Type-Options help reduce other attacks like XSS that could complement SQLi.
